Hawkes non parametric inference
===============================

.. contents::
    :depth: 2
    :backlinks: none

.. testsetup:: *

    import numpy as np
    from mlpp.hawkesnoparam.estim import Estim
    from mlpp.simulation import SimuHawkes, HawkesKernelExp, HawkesKernelPowerLaw

Case of a 2-dimensional Hawkes process with exponential kernels
---------------------------------------------------------------

We simulate a 2-dimensional Hawkes process with exponential kernels

.. testcode:: [exp_kernels]

    h = SimuHawkes(kernels=[[0, HawkesKernelExp(0.1 / 0.2, 0.2)],
                        [HawkesKernelExp(0.1 / 0.2, 0.2), 0]],
           baselines=[0.05, 0.05], verbose=False)
    h.end_time = 1000000
    h.simulate()

Non parametric estimation is two steps.

- First step consists in computing the conditionnal laws
- Second step to solving the Wiener-Hopf equation using quadrature

The first step is obtained by creating an `Estim` object from the `SimuHawkes`
object.

.. testcode:: [exp_kernels]

    e = Estim(h)

Let us point out that the previous line allows the object e to know about the
whole Hawkes process, so that it can display (see later on) the exact kernels
and compare them with the estimation. If you don't want to do that, you could
have typed instead

.. testcode:: [exp_kernels]

    e = Estim(h.process)

Here the Hawkes realization is just given by a list of np.arrays corresponding
to the arrival times of each component

It's time to solve the Wiener Hopf equation

.. testcode:: [exp_kernels]

    e.compute()

We can have a look at the result:

.. doctest:: [exp_kernels]

    >>> # The exogeneous intensities
    >>> print(e.mu) # doctest: +SKIP
    [0.04942, 0.0495]
    >>> # The matrix of the norms
    >>> e.norm # doctest: +SKIP
    matrix([[ 0.0490553 ,  0.44758089],
            [ 0.53529197, -0.03144761]])
    >>> e.plot() # doctest: +SKIP

.. plot:: z_tutorials/inference/code_samples/hawkes_non_parametric_exp.py


Case of a 2-dimensional Hawkes process with power-law kernels
-------------------------------------------------------------

Remember that a truncated powerlaw kernel has the form

.. math::

    \phi(t) = \alpha (t+\delta)^{-\beta}

The support is computed such that :math:`\phi(support) = error` which by
default is :math:`10^{-5}`.

.. doctest:: [power_law_kernels]

    alphas = np.array([0.012, 0.008, 0.004, 0.0005])
    delta = 0.0005
    beta = 1.3

    hawkes = SimuHawkes(kernels=[[HawkesKernelPowerLaw(alphas[0], delta, beta, 2000),
                              HawkesKernelPowerLaw(alphas[1], delta, beta, 2000)],
                             [HawkesKernelPowerLaw(alphas[2], delta, beta, 2000),
                              HawkesKernelPowerLaw(alphas[3], delta, beta, 2000)]],
                    baselines=[0.05, 0.05], verbose=False)

    hawkes.end_time = 50000
    hawkes.simulate()

We now create an `Estim` object. It's time to learn about the options.
The main options are about how the conditionnal laws are sampled. There are 2
choices

- claw_method = "lin" : (default value)
    the conditionnal laws are sampled linearly on :math:`[0, h_{max}]` using
    step :math:`h_{delta}`

- claw_method = "log" :
    the conditionnal laws are sampled using a semi-log sampling :

    - linear on :math:`[0,h_{min}]` using step :math:`h_{delta}`
    - log on :math:`[h_{min},h_{max}]` using step :math:`e^{h_{delta}}`

The semi-log sampling is better for powerlaw kernels

.. doctest:: [power_law_kernels]

    e = Estim(hDelta=0.1, hMax=100, hMin=0.002, claw_method="log")

Let us point out that we haven't given the Estim object a realization yet.
We need to do so (we could have done it at the creation as in the example
above)

.. doctest:: [power_law_kernels]

    # You can add several realizations this way
    e.add_realization(hawkes)

    # Again you could have done instead
    # e.add_realization(hawkes.process)

Then we perform the solving of the Wiener Hopf equation. Let's look at the
options again. It is solved using a quadrature method. You have to choose the
number of quadrature points (`n_quad`). The interval the kernels will be
estimated [`xmin`, `xmax`] and the quadrature method (you can use either
`"log"`, `"lin"` or `"gauss"`).

.. doctest:: [power_law_kernels]

    e.compute(n_quad=50, xmax=2000, xmin=0.002, method="log")

For displaying powerlaw kernels it is better to use log-log-scales

.. doctest:: [exp_kernels]

    >>> e.plot(loglogscale=True) # doctest: +SKIP

.. plot:: z_tutorials/inference/code_samples/hawkes_non_parametric_power_law.py

A case with Time function kernels and negative kernels
------------------------------------------------------

..
   This code takes ~30 seconds to run, hence we do not include it as doctest
   but we rather show it and the figure it generates. Hence it is not guarantee
   to work, and must be checked times to times.

.. literalinclude:: code_samples/hawkes_non_parametric_time_function.py
   :language: python

.. image:: code_samples/hawkes_non_parametric_time_function.png



